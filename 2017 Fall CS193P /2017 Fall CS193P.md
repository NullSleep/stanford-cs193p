# LESSON 1

## Prerequisites
- Object oriented programming

## Side Notes
- For a serious computer scientist another language is "big yawn". Just give me the syntax, tell me what are key fundamental design fundamental principles and we'll go at it.

## iOS
- iOS is UNIX. It is a BSD variant of UNIX. It's an OS X fork. And it's written in C. Most of the low level API are written in C.
- App delegate is your application's way of communicating with the operating system.
- Upper left is the origin for any element in the UI.

## Layers of iOS
Lower to higher layers of iOS:
1. CORE OS: OS X Kernel, Mach 3.0, BSD, Sockets, Security, Power management, Keychain access, Certificates, File system, Bonjour
2. CORE SERVICES: Collections, Address Book, Networking, File access, SQLite, Core location, Net services, Threading, Preferences, URL Utilities
3. MEDIA: Core audio, OpenAL, Audio mixing, Audio recording, Video playback, JPEG, PNG, TIFF, PDF, Quartz (2D), Core animation, OpenGL ES, Metal
4. COCOA TOUCH: Multi-touch, core motion, view hierarchy, localization, controls, alerts, web view, map kit, image picker, camera

## Swift
- Swift is an extremely strongly typed language. It also has strong type inference and it will, if it can, guess the type for you.
- In Swift you can have as many functions as you like as long as they have different arguments (parameters)
- Copy on write one of it's biggest features. When an object like an struct is passed around it's only copied when it's modified.
- nil in Swift means the not set case of an optional.
- The _ indicates to the Swift compiler that we’re not going to use this value so ignore it.
- Exit: force quit an app with no debug feed.
- Between guard and the new throw statement for error handling, Swift encourages a style of early return rather than nested if statements.

## GLOBAL FUNCTIONS
Global functions can be declared outside classes. In object oriented programming there are no global functions.

## ARGUMENTS IN SWIFT IN SWIFT (DIFFERENCE BETWEEN SWIFT A MOST OTHER LANGUAGES)
In functions every argument has to have a name that is included when called. And it can have 2 names. An internal name and an external name. It is perfectly legal to have only name.
Example:
· func addNumbers(for number1: Int, and number2: Int) { }
· addNumbers(for: 23, and: 45)

- No parameter name: IBAction func touchCard(_ sender: UIButton) { }
'_ sender' the underscore indicates that there is no argument (like java or other languages) It is in IBAction because it comes from the Obj-C world. But 'underbar' is rarely used.

## HOW TO NAME FUNCTIONS ON IOS
The most important rule to remember is that naming a function and its parameters is that when someone calls that function it should read like english.

## PROPERTIES = MESSAGES
Accessing an objects property can also be called sending a message
button.<message>

## PRINTING SOMETHING AS A STRING
Whatever you put inside \() will be interpreted as String
print("flipcard(withEmoji: \(emoji)")

## INSTACE VARIABLE (PROPERTIES)
All instance variables in Swift have to be initialized.
Two ways of initializing:
- Initializer - Init: Method with specific arguments. Can have multiple inits each with different arguments but each Init has to initialize all of the variables.
- Setting the value directly

* An optional variable doesn't need to be initialized because by default is set to nil
* Adding an init to a class can be difficult if that class has inheritance. You must make sure to call of the init of the class it's inheriting.

## VARIABLES
- If the type can be easily inferred do not add any type. Swift is an extremely strongly typed language. It also has strong type inference and it will, if it can, guess the type for you.

## PROPERTY OBSERVERS
Any property can have code after it. They are useful to keep the UI in  with instance variables.
For the didSet property observer it will execute every time the property is set.

var flipCount = 0 {
  // It will execute the code every time flipCount changes
  didSet {
      flipCountLabel.text = "Flips: \(flipCount)"
  }
}

## IBOUTLETS, IBACTIONS AND OUTLET COLLECTION
IBOutlets: Instance variables (or property) connected to an UI element
IBActions: Methods connected to an UI action
IBOutlets Outlet Collection: An array of the things in the UI

* IBAction and IBOutlet are not part of a Swift method. It's just a special directive that XCode puts that causes the connection circle to appear along with its functionality (display which element in the interface builder is connected or to allow a connection, etc)
* Swift can't infer the type that comes from a UI file. That is why IBOutlets have to put the type in the function.

## INITiALIZING AN ARRAY
4 Ways of initializing an empty array in Swift:
- var arr = [Int]() // Shorthantd Syntax
- var arr = Array<Int>() // Array Initializer
- var arr: [Int] = [] // Array with an array literal -> var arr: [Int]!
- var arr: Array<Int> = []

* Setting Array<String> is not necessary because Swift can infer that type easily just like a human would.

## COLLECTIONS (ARRAY, SET OR DICTIONARY) MUTABILITY
In Swift it is good practice to create immutable collections in all cases where the collection does not need to change. Doing so makes it easier for you to reason about your code and enables the Swift compiler to optimize the performance of the collections you create.

## DATA DRIVEN
Setting the data and making the UI adapt to it. i.e. My game will have as many cards and it will know it's content given the data I have in the app (an array or a dictionary or JSON file)

## OPTIONALS
- Its a value that can have only two states: Set and not set. It is an enumeration (data structures that have a discrete set of values) with only two values.
- It is an enumeration. For each case of an enumeration you have associated data. In this case a set value or nil.
enum Optional<T> { // A generic type, like Array<Element> or Dictionary<Key, Value>
  case none
  case some(<T>) // The some case has associated data of type T
}
- An optional when it is in the set state has associated data (Int?, String?)
- ! an exclamation point at the end of an optional: indicates the compiler: assume the associated value is set and grabs the associated value. If there is no value it will crash.
- If Let: Does the same as ! but doesn't crash it just doesn't execute.

* Depending on the case you want the ! to crash because a value should have been there. It's ok to use ! to crash the app.

* Optionals are so important that even though they are just a regular enum they have a special syntax for it:
  + The "not set" has a special keyword: nil
  + The character ? is used to declare an Optional, e.g. var indexOfOneAndOnlyFaceUpCard: Int?
  + The character ! is used to 'unwrap' the associated data if an Optional is in the "set" state: e.g. let index = cardButtons.index(of: button)!
  + The keyword 'if' can also be used to conditionally get the associated data: e.g. if let index = cardButtons.index(of: button) { }
  + An Optional declared with ! (instead of ?) will implicitly unwrap (add !) when accessed: e.g. var flipCountIndex: UILabel! enables flipCountIndex.text = "..." (no ! needed here)
  + You can use ?? to create an expression which "defaults" to a value if an Optional is not set: e.g. return emoji[card.indentifier] ?? "X"
  + You can also use ? when accessing an Optional to bail out of an expression midstream. This is called Optional chaining.

- Declaring and assigning values to an Optional:
var hello: String?              var hello: Optional<String> = .none
var hello: String? = "hello"    var hello: Optional<String> = .some("hello")
var hello: String? = nil        var hello: Optional<String> = .none

- Unwrapping
let hello: String? = ...
print(hello!)
=
switch hello {
  case .none: // raise an exception (crash)
  case .some(let data): print(data)
}

if let greeting = hello {
  print(greeting)
} else {
  // Do something else
}
=
switch hello {
  case .some(let data): print(data)
  case .none: { // Do something else }
}

- Implicitly unwrapped
var hello: String!
hello = ...
print(hello) // No exclamation point needed
=
var hello: Optional<String> = .none
switch hello {
  case .none: // raise an exception (crash)
  case .some(let data): print(data)
}

- Nil coalescing operator:
let x: String? = ...
let y = x ?? "foo"
=
switch x {
  case .none: y = "foo"
  case .some(let data): y = data
}

- Optional chaining:
let x: String? = ...
let y = x?.foo()?.bar?.z
=
switch x {
  case .none: y = nil
  case .some(let data1):
    switch data1.foo() {
      case .none: y = nil
      case .some(let data2):
        switch data2.foo() {
          case .none: y = nil
          case .some(let data3): y = data3.z
        }
    }
}

## STRUCTS VS CLASSES
In C a Struct is just a lightweight data structure that holds little bits of data.

In Swift Struct and Classes are almost the same. They both can have methods, variables, etc. Two major differences:
1. Structs have no inheritance. Therefore Structs are simpler. They don't have to worry about what it is inheriting and what that might mean.
2. Structs are value types and Classes are reference types (object). Value types get copied when passed around as an attribute, put on an array or assigned to a variable. Reference types, live in the heap, it has pointers, and when you pass it around you are passing the pointer.

* In Swift Arrays, Ints, Strings, Dictionaries are Structs. When they are passed around they get copied, to avoid inefficiencies it doesn't copy all the bits of all they things, it passes it in a way that it only has to make copies when someone modifies it, it is called copy on write semantics.

In Sswift:
- Classes get a free empty init with no arguments as long as all of their variables are initialized
- Structs also get a free initializer method that will have parameters to initialize all of its variables.

## COUNTABLE RANGES
CountableRange is a generic type. It can count over multiple types (int, double, etc)

for identifier in 0..<numberOfPairsOfCards
from 0 up to and not including numberOfPairsOfCards

for identifier in 0...numberOfPairsOfCards
0 to numberOfPairsOfCards including numberOfPairsOfCards

- stride is a function that create a countable range.
for i in stride(from: 0.5, to: 15.25, by: 0.3) {
    print(i)
}

## STATIC FUNCTIONS AND VARS
Static functions and vars are TYPE functions and vars. It's a function that can't be sent to its instance. Its instance will not understand it. Kind of like a global function or utility function tied to the class that implements it. The type does understand it, so we can send it to the type itself.

class Card {
  static var value = 0
  static func function() {}
}

Instead of:
let card = Card()
let numX = card.function() // Doesn't work. It won't find it.

It becomes:
let numX = Card.function()

A static var is a variable that can be stored with the type, not with each individual instance.

## LAZY VARIABLES
- A lazy stored property is a property whose initial value is not calculated until the first time it is used. You indicate a lazy stored property by writing the lazy modifier before its declaration.
- Lazy properties are useful when the initial value for a property is dependent on outside factors whose values are not known until after an instance’s initialization is complete. Lazy properties are also useful when the initial value for a property requires complex or computationally expensive setup that should not be performed unless or until it is needed.
- They can't have a didSet.

lazy var decimalFormatter: NumberFormatter = {
  let formatter = NumberFormatter()
  formatter.numberStyle = .decimal
  return formatter
}()

## MODEL VIEW CONTROLLER (MVC)
Popular software design pattern in web and mobile. It is based on separating your app code into 3 distinct roles:

Model:
The model represents the data in our app, and holds the logic for what we do with that data. In the FizzBuzz app the Brain and Game are part of the model.

View:
The view is the user interface. It's what the user sees and interacts with. In iOS development you can create views graphically with Storyboards.

Controller:
The controller manages the communication between the view and the model. It takes the data from the model and communicates it to the view for display. The controller also takes the user's input and communicates it back tot the model. In iOS, controllers are called ViewControllers. In the FizzBuzz app, the view controller takes the user interaction with the view (i.e. tapping the Fizz button), communicate tot the model (the Brain). The model will check if the move is right or wrong, and communicate this to the view controller. The view controller will then change the view to let the user know whether the were right or wrong.

## STORYBOARDS
“A storyboard is a visual representation of the app’s user interface, showing screens of content and the transitions between them.”

## IF != NIL SHORTHAND SYNTAX IN SWIFT
// Looking for value in a dictionary always returns an optional
if dict[key] != nil {
    return dict[key]!
} else {
    return  ""
}

Exactly the same:
return dict[key] ?? ""

## AUTOLAYOUT
Auto Layout dynamically calculates the size and position of all the view in your view hierarchy, based on constraints placed on those views. For example, you can constrain a text field so that the text field's top edge always remains 8 points below the view's top. If the view's size or position changes, the text field's position automatically adjusts to match.

## IF AFTER IF SWIFT SYNTAX
This:
if a = true {
  if n = true  {
  }
}

Is the same as:
if a = true, n = true  {
}

It reads as "if a is true and if n is true do the following".

## TUPLES
- Nothing more than a grouping of values. You can use it anywhere you can use a type.

let x: (String, Int, Double) = ("Hello", 5, 0.85) // The type of x is a tuple
let (word, number, value) = x
print(word)
print(number)
print(value)

- Or the tuple elements can be named when the tuple is declared (this is strongly preferred)
let z: (w: String, i: Int, v: Double) = ("Hello", 5, 0.85)
print(z.w)
print(z.i)
print(z.v)

- This also legal
let (wrd, num, val) = x
print(wrd)
print(num)
print(val)

- Tuples are great to returning multiple values from a function or a method.
let size = getSize()
print("The weight is \(size.weight)")
print("The height is \(getSize().height)")

func getSize() -> (weight: Double, height: Double) {
  return (250, 80)
}

## COMPUTED PROPERTIES
The value of a property can be computed (calculated when accessed or assigned) rather than stored.

A typical property looks something like this:
var foo: Double

A computed property looks like this:
var foo: Double {
  get {
    // Return the calculated value of foo
  }
  set(newValue) {
    // do something based on the fact that foo has changed to newValue
  }
}

It is not necessary to implement the set (the property then becomes read only)

IMPORTANT: Foo is never stored anywhere instead every time someone asks for foo it gets calculated with the code inside get. And every time someone set the value of foo the code inside set gets executed. Why are they important? What do you use them for? A lot of time many properties are derived from other states inside the struct or class, so you don't want duplicated information that can get out of sync. So it is better to derive the information.

## ACCESS CONTROL
- Protecting internal implementations: On big projects is important to be able to protect the INTERNAL implementation of data structures. You do this by making the API (methods and properties) you want other code to use with certain keywords. This are put in front of var, structs, methods or classes.
- internal: This is the default, it means "usable by any object in my app or framework".
- private: "Only callable from within this object"
- private(set): this property is readable outside this object, but no settable.
- fileprivate: Since you can have multiple classes and structs in a file a fileprivate var o methods can be accessible by any code in this source file.
- public: (for frameworks only) this can be used by objects outside my framework.
- open: (for frameworks only) public and objects outside my framework can subclass this.

* A good strategy is to just mark everything as private by default. Then remove the private designation when that API is ready to be used by other code.

## EXTENSIONS
- Adding methods/properties to a class/struct/enum (even if you don't have the source) to extend existing data structures. You can add extensions to Int, UIButton, or any type of data structures.
- Restrictions: You can't re-implement methods or properties that are already there (only add new ones). The properties you add can have no storage associated with them (computed only)
- This feature is easily abused:
  + It should be used to add clarity to readability not obfuscation.
  + Don't use it as a substitute for good object-oriented design technique.
  + Best used (at least for beginners) for very small, well-contained helper functions.
  + Can actually be used well to organize code but requires architectural commitment.
  + When in doubt, don't do it.

## ENUM
- Another variety of data structure in addition to struct and class. It can only have discrete values (for example the 4 values assigned below and that is it):
enum FastFoodMenuItem {
  case hamburger
  case fries
  case drink
  case cookie
}

- An enum is VALUE TYPE (like struct) so it is copied as it is passed around.

- Enums in Swift can have associated data for each case:
enum FastFoodMenuItem {
  case hamburger(numberOfPatties: Int)
  case fries(size: FryOrderSize)
  case drink(String, ounces: Int) // The unnamed string is the brand e.g. "Coke"
  case cookie
}
enum FryOrderSize {
  case large
  case small
}

- Setting the value of an enum
let menuItem: FastFoodMenuItem = FastFoodMenuItem.hamburger(patties: 2)
let otherItem: FastFoodMenuItem = FastFoodMenuItem.cookie
var yetAnotherItem = .cookie // Swift can't figure this out

- Checking an enum's state:
* An enum's state is checked with a switch statement

var menuItem = FastFoodMenuItem.hamburger(patties: 2)
switch menuItem {
  case FastFoodMenuItem.hamburger:
    print("burger")
  case FastFoodMenuItem.fries:
    print("Fries")
  case FastFoodMenuItem.drink:
    print("drink")
  case FastFoodMenuItem.cookie:
    print("cookie")
}

* It is not necessary to use the fully expressed FastFoodMenuItem.fries inside the switch (since Swift can infer the FastFoodMenuItem part of that)
var menuItem = FastFoodMenuItem.hamburger(patties: 2)
switch menuItem {
  case .hamburger:
    break
  case .fries:
    print("Fries")
  case .drink:
    print("drink")
  default:
   print("other")
}

- Associated Data:
var menuItem = FastFoodMenuItem.drink("Coke", ounces: 32)
switch menuItem {
  case .hamburger(let pattyCount): print("a burger with \(pattyCount) patties")
  case .fries(let size): print("a \(size) order of fries")
  case .drink(let brand, let ounces): print("A \(ounces)oz \(brand)")
  default: print("other")
}

- Methods yes, properties no. An enum can have methods and computed properties, but no stored properties

* An enum's state is entirely which case it is in and that case's associated data.
emun FastFoodMenuItem {
  case hamburger(numberOfPatties: Int)
  case fries(size: FryOrderSize)
  case drink(String, ounces: Int) // The unnamed string is the brand e.g. "Coke"
  case cookie

  // Computed property
  var calories: Int { //calculate and return caloric value here }

  func isIncludedInSpecialOrder(number: Int) -> Bool {
    // In an enum's own methods, you can test the enum's state (and get associated data) using self
    switch self {
      case .hamburger(let pattyCount): return pattyCount == number
      case .fries, .cookie: return true // A drink an a coke in every special order
      case .drink(-, let ounces): return ounces == 16
    }
  }

  // You can modify self in enum. 'mutating' is required because enum is a Value Type. Since enums are Value Types and Value Types are passed by copying on write (it only makes a
  // copy until you write) so it needs to know which functions might write. Using 'mutating' is exactly the same on Structs.
  mutating func switchToBeingACookie() {
    self = .cookie // This work eve if self is a .hamburger, .fries, etc
  }
}

## DATA STRUCTURES
- Four essential data structure-building concepts in Swift:
  + class
  + struct
  + enum
  + protocol

## CLASSES
  + Support object-oriented design. A class is meant to define an object and how it works. In this way, a class is like a blueprint of an object.
  + Single inheritance of both functionality and data (i.e. instance variables)
  + Reference type (classes are stored in the heap and are passed around via pointers)
  + Heap (dynamic memory allocation) is automatically "kept clean" by Swift (via Automatic Reference Counting, not garbage collection)
  + Examples: ViewController, UIButton, Concentration
  * An object is an instance of a class.

## ARC AUTOMATIC REFERENCE COUNTING
Reference types (classes) are stored in the heap (dynamic memory allocation). How does the system know when to reclaim the memory for these from the heap? It count references to each of them and when there are no longer in use (nil for an optional) it decreases the counter. It is done automatically and it is not garbage collection.

You can influence ARC by how you declare a reference-type var with these keywords:
- strong: Normal reference counting. As long as anyone, anywhere has a strong pointer to an instance, it will stay in heap. This is the default value.
- weak: Means "if no one else is interested in this, then neither am I, set me to nil in that case" Because it has to be nil-able, weak only applies to Optional pointers to reference types. A weak pointer will NEVER keep an object in the heap. Outlets are strongly held by the view hierarchy, so outlets can be weak.
- unowned: Don't reference count this, crash if I'm wrong. Rarely used. Usually only used to break memory cycles between objects.

## PROTOCOLS
- Protocol is data structure that functions as a first class type.
- A way to express an API more concisely.
- Instead of forcing the caller of an API to pass a specific class, struct, or enum, an API can let caller pass any class/struct/enum that the caller wants but can require that they implement certain methods and/or properties that the API wants.
- The API expresses the functions or variables it wants the caller to provide using a protocol.
- So a protocol is simply a collection of methods and properties declarations.

What are they good for:
- Making API more flexible and expressive.
- Blind, structured communication between View and Controller (delegation)
- Mandating behavior (Dictionary is a HasTable, so the keys has to be hashable.)
- Only inherits functionality, no data

Three aspects to a protocol:
- Declaration (methods and vars)
- Class, struct, enums claims that it implements a protocol
- The code that implements the protocol methods and vars

+ Declaration of a protocol:
protocol bokuNoProtocol: InheritedProcotol1, InheritedProcotol2 {
  var someProperty: Int { get set }
  func aMethod(arg1: )
  mutating func changeIt()
  init(arg: Type)
}

* anyone that implements bokuNoProtocol has to implement InheritedProcotol1 and InheritedProcotol2. Protocol inheritance
* Protocols have no code. They are only declarations, no implemention.
* You must specify whether a property is get only or both get and set
* Any function that are expected to mutate the reciever should be named "mutating"
* If you want to restrict your protocol to a class, implementers must claims the implementation of a protocol by adding class
* If a protocol has an init the implementer must have that init as well

+ Claiming to implement a protocol:
class/struct/enum someClass: SuperclassOfSomeClass someProtocol, anotherProtocol {
  // someClass implementation here
  // which must include all the properties and methods in someProtocol and anotherProtocol
  required init()
}

* Claims of conformance to protocols are listed after the superclass for a class
* Any number of protocols can be implemented by a given class, struct or enum
* In a class, inits must be marked required (or otherwise a subclass might not conform)
* You are allowed to add a protocol conformance via an extension
* In Swift all of the methods and variables are mandatory. In Obj-C they can be optional.

- Uses of protocols:
  + Delegation and delegates: It's a way to implement "blind communication" between a view and its Controller:
    1. A View declares a delegation protocol (i.e. what the View wants the controller to do for it.)
    2. The Views API has weak delegate property whose type is that delegation protocol.
    3. The View uses the delegate property to get/do things it can't own or control on its own.
    4. The Controller declares that it implements the protocol.
    5. The Controller sets delegate of the View to itself using its public property delegate (point 2)
    6. The Controller implements the protocol.
  + A key in a dictionary has to be unique. This is enforced by requiring that a Dictionary's keys implement the Hashable protocol:
    protocol Hashable: Equatable {
      var hasValue: Int { get }
    }
    Hashable inherits from Equatable. That means that to be a hashable, you also have to implement Equatable.
    protocol Equatable {
      static func ==(lhs: Self, rhs: Self) -> Bool
    }
    Types that conform to Equatable have to have a type function (note the static) called ==.  The oeprator == also happens to look for such static method to provide its implementation.

    Dictionary is then declared like this: Dictionary<Key: Hashable, Value> Key can only work if it implements Hashable while value can be of any type.

  + Multiple inheritance with protocols:

## STRINGS
Collection of Characters. It's a value type.

for c in s {
}

let characterArray = Array(s) // Array<Character>

String is made up of unicode. Also there is Character (what a human would consider as a single lexical character) which can be made up of multiple Unicodes.
Café can have 4 Characters or either 4 (Café) or 5 unicodes (Cafe´). In either case we perceive it as 4 Characters.
Because of this ambiguity, the index into a String cannot be an Int.
Indices into String are therefore of a different type String.Index, String.startIndex, String.endIndex, String.index(of:)
To move to a another index: index(String.Index, offsetBy: Int)

let pizzaJoint = "café pesto"
let firstChracterIndex = pizzaJoint.startIndex
let fourthChracterIndex = pizzaJoint.index(firstChracterIndex, offsetBy: 3)
let fourthChracter = pizzaJoint.index[fourthChracterIndex] // é

if let firstSpace = pizzaJoint.index(of: " ") { // Returns nil if " " not found
  let secondWordIndex = pizzaJoint.index(firstSpace, offsetBy: 1)
  let secondWord = pizzaJoint.index[secondWordIndex..<pizzaJoint.endIndex] // é
}
..< This is a Range of String.Index. Range is a generic type (like Array)

Another way to find the second word: pizzaJoint.components(separatedBy: " ")[1]
pizzaJoint.components(separatedBy:) returns Array<String> (might be empty)

## NSATTRIBUTEDSTRING
- A completely different data structure that String. The NS is a clue that is an "old style" Obj-C class.
- Since it's not a value type, you can't create a mutable NSAttributedString by just using var. To get mutability you have to us e a subclass called NSMutableAttributedString.
- NSAttributedString was created with NSString in mind and not Swift's String. NSString and String use slightly different encodings.
- A string with attributes attached to each character. Conceptually, an object that pairs a String and a Dictionary of attributes for each Character. The dictionary's keys are like "the font" (UIFont) or "the color" (UIColor)

// The type cannot be inferred here
let attributes: [NSAttributedStringKey: Any] = [
  .strokeColor: UIColor.orange
  .strokeWidth: 5.0
]
let attribtext = NSAttributedString(string: "Flips: 0", attributes: attributes)
flipCountLabel.attributedText = attribtext

## FUNCTIONS AS TYPES
- Functions are types too. First class types.
- You can declare a variable (or parameter to a method or whatever) to be a type "Function"

// This is a var called operation. It is of type "function that takes a Double and returns a Double"
var operation: (Double) -> Double
operation = sqrt // sqrt is just a function (in this case found in Foundation) that takes a Double and returns a Double
// You can "call" this function using syntax very similar to any function call
let result = operation(4.0)

## CLOSURES
- Closures are self-contained blocks of functionality that can be passed around and used in your code. Closures in Swift are similar to blocks in C and Objective-C and to lambdas in other programming languages.
- Closures can capture and store references to any constants and variables from the context in which they are defined. This is known as closing over those constants and variables. Swift handles all of the memory management of capturing for you.
- Closures along with Classes are referenced types and they live in the heap.
- Often you want to create the function "on the fly". You can do this "in line" using a closure.

// Using a conventional way:
func changeSign(operand: Double) -> Double {
 return -operand
}
var operation: (Double) -> Double
operation = changeSign
let result = operation(4.0) // The result will be -4.0

// Using a closure:
var operation: (Double) -> Double
// Move the first { to the start and replace it with an 'in'
// operation = { (operand: Double) -> Double in return -operand }

// Because of type inference Swift knows it returns a double and that 'operand' is a double so you don't need to specify them.
// operation = { (operand ) in return -operand }

// It also knows that you return something so don't need the the return.
// operation = { (operand) in -operand }

// Instead of using operand (or whatever name you want) Swift will let you replace the parameters names $0, $1, $2
operation = { -$0 }
let result = operation(4.0) // The result will be -4.0

- Where do we use closures:
  + Often as arguments to methods.
  + Many times a method wants to know "what to do" and providing a function tells it what to do. For example, what to do when there's an error or when somehting asyncronous finishes. Or maybe you want to ask some method to repeatedly perform a function.
  + Array has a methods called map which takes a function as an argument. It applies that function to each element of the Array to create and return a new Array. Perfectly valid initializations:

    let primes = [2.0, 3.0, 5.0, 7.0, 11.0]
    let negativePrimes = primes.map({ -$0 }) // [-2.0, -3.0, -5.0, -7.0, -11.0]
    let invertedPrimes = primes.map() { 1.0 / $0} // [0.5, 0.333, 0.3, ...]
    * IMPORTANT: If the last (or only) argument to a method is closure  you can put it outside the method's parentheses that contain its arguments and if the closure was the only argument, you can skip the () completely if you want.
    let primeStrings = primes.map() { String($0) } // ["2.0", "3.0", "5.0", "7.0", "11.0"]

  + Property initialization. You can execute a closure to do initialization of a property if you want:
    var someProperty: Type = {
      // Construct the vale of some property here
      return <the constructed value>
    }()
    * This is specially useful with lazy property initialization.

  + Closures capture their surrounding variables, local, instance, the closure is in. Closures are referenced types and they live in the heap. They capture variables they use from the surrounding code into the heap too. Those captured variables need to stay in the heap as long as the closure stays in the heap.

    var ltuae = 42
    operation = { ltuae * $0 } // Captures the ltuae var because it's needed for this closure.
    arrayOfOperations.append(operation)
    // If we later change ltuae, then the next time we evaluate operation it will reflect that even if we leave the scope (function or whatever) that this code is in.
    // This can create a memory cycle. Because you are capturing the class is in.


## SWIFT SHORTHANDS AND CODE SAMPLES
Option 1
if cards[index].isFaceUp {
    cards[index].isFaceUp = false
} else {
    cards[index].isFaceUp = true
}

Option 2
cards[index].isFaceUp = cards[index].isFaceUp ? false : true

- *How to quickly append to an Array using subscript:*

// Option 1
// When you append the card to the array it also copies it.
// cards.append(card)
// cards.append(card)

// Option 2
cards += [card, card]

## --

// structs have a free initializer
// let card = Card(isFaceUp: , isMatched: , identifier: )

## --

// Long version
//    var numberOfPairsOfCards: Int {
//        get {
//            return (cardButtons.count + 1) / 2
//        }
//    }
// Short version. We can do this only because it is read-only (only has a get)
var numberOfPairsOfCards: Int {
    return (cardButtons.count + 1) / 2
}

## --

// cardButtons is a sequence of buttons so we can loop through it.
      for button in cardButtons { }
// Countable range
       for index in 0..<cardButtons.count { }

// Looking for value in a dictionary always returns an optional
       let choosenEmoji = emoji[card.identifier]

## --
       // Another way of dealing with optionals
//        if emoji[card.identifier] != nil {
//            return emoji[card.identifier]!
//        } else {
//            return "!!!"
//        }

- *Replacing for loops with closures on higher order function in Array:*
var foundIndex: Int? // From this declaration optionals always starts at nil
for index in cards.indices {
    if cards[index].isFaceUp {
        if foundIndex == nil {
            foundIndex = index
        } else {
            return nil
        }
    }
}
return foundIndex

// faceUpCardIndices is of type: [Array, index]
let faceUpCardIndices = cards.indices.filter { cards[$0].isFaceUp }
return faceUpCardIndices.count == 1 ? faceUpCardIndices.first : nil

- *Simplifying searching for unique values in an arrays*
To go deeper to solve the problem with indexOfOneAndOnlyFaceUpCard we can create an extension of Collection (array is a Collection) and we can extend it:
// Option 1
// If array has only index in it we return it
let faceUpCardIndices = cards.indices.filter { cards[$0].isFaceUp }
return faceUpCardIndices.count == 1 ? faceUpCardIndices.first : nil

// Option 2
return cards.indices.filter { cards[$0].isFaceUp }.oneAndOnly

// Collection is a generic type. Already has Element
extension Collection {

    var oneAndOnly: Element? {
        // count and first are Collection methods
        return count == 1 ? first
    }
}

* With this extension you could do:
let ch = "hello".oneAndOnly // This would be nil
let ch = "h".oneAndOnly // This would return "h" The one and only element in the String

## THROWING ERRORS
In Swift methods can throw errors. You will always know that can throw because they'll have the keyword throws on the end.
func save() throws {
 // You must put calls to functions like this in an do { } block and use the word try to call them.
 do {
   try context.save()
 } catch let error {
   // Error will be something that implements the Error protocol, e.g. NSError: usually these are enums that have associated values to get error details.
   throw error // This would re-throw the error (only ok if the methods we are in throws)
 }
}

// If you are certain a call will not throw, you can force try with try! This is not done often.
try! context.save() // will crash your program if save() actually throws an error

// A better one. Please try this and if it throws an error don't crash ignore the fact that it threw. If I need the int that returns and it returns an error then it will give me a nil.
let x = try? errorProneFunctionThatReturnAndInt()

## TYPE ANY ANYOBJECT
- Special types: This type used to be commonly used for compatibility with old Obj-C APIs. But not so much anymore in iOS 11 since those old Obj-C APIs have been updated (thou still occasionally can be seen i.e. NSAttributedString)
- It is for backwards compatibility
- Variables of type Any can hold something of any type (AnyObject holds classes only)
- Since Swift is a strongly typed language, though, so you can't invoke a method (send a message) on an Any.
- You have to convert it into a concrete type first.
- One of the beauties of Swift is its strong typing, so generally you want to avoid Any.
* Don't use Any. Only for backwards compatibility when an iOS API uses it.

// Attributes  of and NSAttributedStringKey can be of different types.
let attributes: [NSAttributedStringKey: Any] = ...

// UIViewController method that includes a sender (which can be of any type)
func prepare(for segue: UIStoryboardSegue, sender: Any)
// The sender is the thing that caused this "segue" (i.e. a move to another MVC) to occur. The sender might be a UIButton or a UITableViewCell or some custom thing in your code. It's an Optional because it's okay for a segue to happen without a sender being specified.

- How to use it: as? (Casting)
  + Conversion is done with the as? keyword in Swift.
  + Tries to convert to that any and if it can't it returns nil. It's an Optional. You can check to see if something can be converted with the 'is' keyword (true/false)
  + We almost always use as '?' it with the 'if let'

  let unknown: Any =
  if let foo = unknown as? MyType {
    // foo is of type MyType in here so we can invoke MyType methods or access MyType vars in foo.
    // If unknown was not of type MyType, then we'll never get here.
  }

  + Casting with as? is not just for Any & AnyObject. You can cast any type with as? into any other type that makes sense.
  + Mostly this would be casting an object from one of its superclasses down to a subclass.
  + But it could also be used to cast any type to a protocol it implements.

  // "Down-casting" from a superclass down to a subclass:
  let vc: UIViewController = ConcentrationViewController()
  // The type of vc is UIViewController (because we explicitly type it to be). And the assignment is legal because a ConcentrationViewController is UIViewController.
  // Still we can't say, for example, vc.flipCard(...), since vc is typed as a UIViewController.

  However, if we cast vc to be a ConcentrationViewController, the we dan use it:
  if let cvc = vc as? ConcentrationViewController { // This is called downcasting
     cvc.flipCard(...) // This is okay
  }

## INTERESTING CLASSES
- NSObject: Base class for all Obj-C classes. Some advanced features will require to subclass of NSObject.
- NSNumber: Old generic class number holder for passing them in Obj-C is. Any type of number (double, int, float). Not required in Swift because the number types are already bridged.
- Date: Value type used to find out the date and time right now or to store past and future dates. There are localization ramifications given the region.
- Data: A bag of bits. To save/restore/transmit raw data throughout the iOS SDK.


## HOW DO SEGUES WORK
- Uno registra los segues en los storyboards con ids y le pone propiedades
- Uno le dice al código que haga el segue con el id previamente dado
- Uno en prepare for segue prepara los datos que va a recibir el controlador que recibe

## COMPARISONS USING ?
return (bool operation) ? 1.5 : 2.5
                         true : false

## TYPEALIAS
A type alias allows you to provide a new name for an existing data type into your program. ... They simply provide a new name to an existing type. The main purpose of typealias is to make our code more readable, and clearer in context for human understanding.

## MULTIPLE SCALE FACTORS
If your assets library contains art for multiple scale factors, (i.e. 1x, 2x, 3x), be sure to configure the scene size for the 1x artwork. iOS will automagically use the correct artwork for the currently running device.
